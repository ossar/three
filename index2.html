<!DOCTYPE html>
<html>
<head>
    <meta charset=utf-8>
    <title>My first Three.js app</title>
    <style>
    body { margin: 0; }
    canvas { width: 100%; height: 100% }
    </style>
</head>
<body>
<script src="js/three.js"></script>
<script>

// 時間係数（日）
var kTime = 1;

// 距離係数（km）
var kDist = 5 / 1e+7;

// サイズ
//var kSize = 3 / 1e+7;
var kSize = kDist;
var kPlanet = 20;

// データ
var pData = {
    //       [直径        公転半径   自転    公転     色       ]
    'Sun'  : [1.392e+7  , 0        , 27.25 , 0      , 0xff8844 ],
    'Earth': [1.2756e+5 , 1.496e+8 , 1     , 365.24 , 0x5588ff ],
    'Mars' : [6.7974e+4 , 2.279e+8 , 1.026 , 686.98 , 0xff6688 ],
    'Moon' : [3.4758e+4 , 3.844e+6 , 27.3  , 27.3   , 0xffff00 ],
};

// シーン
var scene = new THREE.Scene();

// カメラ
var camera = new THREE.OrthographicCamera( -80, 80, 80, -80, 0.1, 10000 );
camera.position.z = 100;
camera.position.y = -200;
camera.lookAt( scene.position );

// レンダラ
var renderer = new THREE.WebGLRenderer();
renderer.setSize( window.innerWidth, window.innerHeight );
document.body.appendChild( renderer.domElement );

// 宇宙
var universe = new THREE.Object3D();
scene.add( universe );

// 太陽軸
//var pivSun = new THREE.Object3D();
//universe.add( pivSun );

// 太陽
//var sun = new THREE.Mesh( new THREE.SphereGeometry(kSize * pData.Sun[0], 10, 10), new THREE.MeshBasicMaterial({ color: pData.Sun[4], wireframe: true, }) );
//sun.rotation.x = -Math.PI/2;
//sun.rotation.reorder('ZXY');
//pivSun.add( sun );

var sun = generatePlanet(pData.Sun);
universe.add( sun.axis );

// 地球軸
var pivEarth = new THREE.Object3D();
sun.axis.add( pivEarth );
pivEarth.position.x = kDist * pData.Earth[1];

// 地球
var earth = new THREE.Mesh( new THREE.SphereGeometry(kSize * kPlanet * pData.Earth[0], 8, 8), new THREE.MeshBasicMaterial({ color: pData.Earth[4], wireframe: true, }) );
pivEarth.add( earth );
earth.rotation.x = -Math.PI/2;
earth.rotation.reorder('ZXY');

// 地球公転
var qtnEarth = new THREE.Quaternion();
qtnEarth.setFromAxisAngle( new THREE.Vector3( 0, 0, 1), 2 * Math.PI / pData.Earth[3] * kTime );

var moon = generatePlanet(pData.Moon, 1);
pivEarth.add(moon.axis);


// 月
// var moon = new THREE.Mesh( new THREE.SphereGeometry(kSize * kPlanet * pData.Moon[0], 8, 8), new THREE.MeshBasicMaterial({ color: pData.Moon[4], wireframe: true, }) );
// pivEarth.add( moon );
// moon.position.x = kDist * pData.Moon[1];
// 
// // 月公転
// var qtnMoon = new THREE.Quaternion();
// qtnMoon.setFromAxisAngle( new THREE.Vector3( 0, 0, 1), 2 * Math.PI / pData.Moon[3] * kTime );

// 火星軸
// var pivMars = new THREE.Object3D();
// pivSun.add( pivMars );
// pivMars.position.x = kDist * pData.Mars[1];
// 
// // 火星
// var mars = new THREE.Mesh( new THREE.SphereGeometry(kSize * kPlanet * pData.Mars[0] , 8, 8), new THREE.MeshBasicMaterial({ color: pData.Mars[4], wireframe: true, }) );
// pivMars.add( mars );
// mars.rotation.x = -Math.PI/2;
// mars.rotation.reorder('ZXY');
// 
// // 火星公転
// var qtnMars = new THREE.Quaternion();
// qtnMars.setFromAxisAngle( new THREE.Vector3( 0, 0, 1), 2 * Math.PI / pData.Mars[3] * kTime );

var mars = generatePlanet(pData.Mars, 1);
sun.axis.add(mars.axis);

function generatePlanet(params, isPlanet) {

    // 座標軸
    var axis = new THREE.Object3D();
    axis.position.x = kDist * params[1];

    // 惑星本体
    var planet = new THREE.Mesh(
        new THREE.SphereGeometry(kSize * (isPlanet ? kPlanet : 1) * params[0] , 8, 8),
        new THREE.MeshBasicMaterial({ color: params[4], wireframe: true, })
    );
    axis.add(planet);

    // 公転
    var quaternion = new THREE.Quaternion();
    if (params[3]) {
        quaternion.setFromAxisAngle( new THREE.Vector3( 0, 0, 1), 2 * Math.PI / params[3] * kTime );
    }

    var plnt = {
        axis : axis,
        planet : planet,
        quaternion : quaternion,
        data : params,
        rotation : function() {
            this.planet.rotation.z = (this.planet.rotation.z + kTime / this.data[2]) % (2 * Math.PI);
        },
        revolution : function() {
            this.axis.position.applyQuaternion( this.quaternion );
        },
    };
    return plnt;
}

// レンダーループ
function render() {
    requestAnimationFrame( render );

sun.rotation();
sun.revolution();
mars.rotation();
mars.revolution();
moon.rotation();
moon.revolution();

    pivEarth.position.applyQuaternion( qtnEarth );
    //moon.position.applyQuaternion( qtnMoon );
    //pivMars.position.applyQuaternion( qtnMars );

    //sun.rotation.z   = (sun.rotation.z   + kTime / pData.Sun[2]  ) % (2 * Math.PI);
    earth.rotation.z = (earth.rotation.z + kTime / pData.Earth[2]) % (2 * Math.PI);
    //moon.rotation.z  = (moon.rotation.z  + kTime / pData.Moon[2] ) % (2 * Math.PI);
    //mars.rotation.z  = (mars.rotation.z  + kTime / pData.Mars[2] ) % (2 * Math.PI);

    renderer.render( scene, camera );
}
render();
</script>

</body>
</html>
